Introduction

C++는 Bjarne Stroustrup가 C 프로그래밍 언어의 확장으로 만든 범용 프로그래밍 언어이다. (source: Wikipedia).

이 모듈의 목표는 여러분에게 객체 지향 프로그래밍을 소개하는 것입니다.
여기가 C++ 여행의 시작점이 될 것입니다.
OOP를 배우려면 여러 언어를 사용하는 것이 좋습니다.
당신의 오랜 친구 C에서 파생된 것이기 때문에 우리는 C++를 선택했습니다.
이것은 복잡한 언어이기 때문에, 그리고 단순함을 유지하기 위해, 당신의 코드는 C++98 표준을 준수할 것이다.

우리는 현대의 C++가 많은 면에서 매우 다르다는 것을 알고 있다. 
따라서 능숙한 C++ 개발자가 되고 싶다면 42 Common Core 이후에 더 나아가야 합니다!

여러분은 새로운 개념을 단계별로 발견할 것입니다. 연습은 점점 복잡해질 것이다.


General rules

Compiling
c++ 및 -Wall -Wextra -Werror 플래그로 코드를 컴파일합니다.
당신이 플래그 -std=c++98을 추가해도 당신의 코드는 여전히 컴파일될 것이다.

Formatting and naming conventions 형식 지정 및 명명 규칙
연습 디렉토리의 이름은 다음과 같습니다 : ex00, ex01, ..., exn
지침에 필요한 대로 파일, 클래스, 함수, 구성원 함수 및 속성의 이름을 지정합니다.
클래스 이름을 UpperCamelCase 형식으로 작성합니다.
클래스 코드가 포함된 파일은 항상 클래스 이름에 따라 이름이 지정됩니다.
예를 들어: ClassName.hpp/ClassName.h, ClassName.cpp 또는 ClassName.tpp.
그런 다음 BrickWall을 나타내는 클래스 "BrickWall"의 정의를 포함하는 헤더 파일이 있으면 이름은 BrickWall.hpp입니다.
달리 지정하지 않는 한 모든 출력 메시지는 줄 바꿈 문자로 끝나야 하며 표준 출력으로 표시되어야 합니다.
Goodbye Norminette! C++ 모듈에는 코딩 스타일이 적용되지 않습니다.
당신은 당신이 가장 좋아하는 것을 따를 수 있다.
그러나 동료 평가자가 이해할 수 없는 코드는 등급을 매길 수 없는 코드임을 명심하십시오.
깨끗하고 읽기 쉬운 코드를 작성하기 위해 최선을 다하세요.

Allowed/Forbidden 허용/금지됨
당신은 더 이상 C에서 코딩하지 않습니다. C++로 갈 시간이야! 따라서:
당신은 표준 라이브러리의 거의 모든 것을 사용할 수 있다.
그러므로, 당신이 이미 알고 있는 것을 고수하는 대신, 당신이 익숙한 C 함수의 C++-ish 버전을 가능한 많이 사용하는 것이 현명할 것이다.
그러나 다른 외부 라이브러리는 사용할 수 없습니다. 이는 C++11(및 파생 형식) 및 Boost 라이브러리가 금지됨을 의미합니다.
*printf(), *alloc() 및 free() 함수도 금지됩니다. 그것들을 사용하면 성적이 0점이 됩니다.
달리 명시적으로 명시되지 않는 한 네임스페이스 <ns_name> 및 friend 키워드를 사용하는 것은 금지됩니다. 그렇지 않으면, 너의 성적은 -42가 될 거야.
모듈 08에서만 STL을 사용할 수 있습니다. 즉, 그때까지 컨테이너(vector/list/map/and 등) 및 알고리즘(<algorithm> 헤더를 포함해야 하는 모든 것)이 없습니다. 그렇지 않으면, 너의 성적은 -42가 될 거야.

A few design requirements 몇 가지 설계 요구 사항
C++에서도 메모리 누수가 발생합니다. new 키워드를 사용하여 메모리를 할당할 때는 메모리 누수를 방지해야 합니다.
모듈 02부터 모듈 08까지, 별도로 명시된 경우를 제외하고는 Orthodox Canonical Form으로 class를 설계되어야 한다.
헤더 파일에 포함된 모든 기능 구현(기능 템플릿 제외)은 연습에 0을 의미한다.
각 헤더를 다른 헤더와 독립적으로 사용할 수 있어야 합니다. 따라서, 그들은 그들이 필요로 하는 모든 의존성을 포함해야 한다.
그러나 포함 가드를 추가하여 이중 포함 문제를 피해야 합니다. 그렇지 않으면, 당신의 성적은 0이 될 것입니다.

Read me
필요한 경우(즉, 코드 분할) 일부 파일을 추가할 수 있습니다. 이러한 할당은 프로그램에 의해 확인되지 않으므로 필수 파일을 제출하는 한 얼마든지 확인하십시오.
때로는 연습의 지침이 짧아 보이지만 예제는 지침에 명시적으로 작성되지 않은 요구사항을 보여줄 수 있다.
시작하기 전에 각 모듈을 완전히 읽으십시오! 진짜, 해봐.

당신은 많은 수업을 시행해야 할 것입니다. 즐겨찾기 텍스트 편집기를 스크립팅할 수 없는 경우 이 작업은 지루해 보일 수 있습니다.

연습을 완료할 수 있는 일정한 자유가 주어집니다.
하지만, 의무적인 규칙을 따르고 게으르지 마세요. 여러분은 많은 유용한 정보를 놓칠 것입니다! 이론적 개념에 대해 읽는 것을 주저하지 마세요.


Exercise 00: Megaphone
모두가 깨어 있는지 확인하기 위해 다음과 같이 동작하는 프로그램을 작성합니다.
C++ 방식으로 연습 문제를 푸세요.


Exercise 01: My Awesome PhoneBook
80년대와 그들의 놀라운 기술에 오신 것을 환영합니다! 형편없는 멋진 전화번호부 소프트웨어처럼 행동하는 프로그램을 작성하세요.
두 개의 클래스를 구현해야 합니다:

PhoneBook 전화번호부
연락처 배열이 있습니다.
최대 8개의 연락처를 저장할 수 있습니다. 사용자가 9번째 연락처를 추가하려는 경우 가장 오래된 연락처를 새 연락처로 교체합니다.
동적 할당은 금지되어 있습니다.

Contact 연락처
전화번호부 연락처를 나타냅니다.

코드에서 전화번호부는 PhoneBook class의 인스턴스로 인스턴스화되어야 합니다.
연락처도 마찬가지로 각 항목은 Contact class의 인스턴스로 인스턴스화되어야 합니다.
원하는 대로 class를 설계할 수 있지만 항상 class 내에서 사용되는 모든 것은 private이며 class 외에 사용할 수 있는 모든 것은 public된다는 것을 명심하십시오.

인트라넷 비디오를 보는 것을 잊지 마세요.

프로그램을 시작할 때 전화번호부가 비어 있고 사용자에게 세 가지 명령 중 하나를 입력하라는 메시지가 표시됩니다. 프로그램은 ADD, SEARCH 및 EXIT만 허용합니다.

ADD : 새 연락처를 저장
사용자가 이 명령을 입력하면 새 연락처 정보를 한 번에 한 필드씩 입력하라는 메시지가 나타납니다. 모든 필드가 완료되면 연락처를 전화번호부에 추가합니다.
연락처 필드는 이름, 성, 별명, 전화 번호 및 가장 어두운 비밀입니다. 저장된 연락처의 필드는 비워둘 수 없습니다.

SEARCH : 특정한 연락처를 보여줌
저장된 연락처를 색인, 이름, 성 및 닉네임의 4개 열 목록으로 표시합니다.
각 열의 너비는 10자여야 합니다. 파이프 문자('|')는 두 문자를 구분합니다. 텍스트가 오른쪽으로 정렬되어야 합니다.
텍스트가 열보다 긴 경우 텍스트를 잘라내고 마지막으로 표시할 수 있는 문자는 점('.')으로 대체해야 합니다.
그런 다음 표시할 항목의 색인을 다시 입력하라는 메시지를 표시합니다. 인덱스가 범위를 벗어나거나 잘못된 경우 관련 동작을 정의합니다.
그렇지 않은 경우, 연락처 정보를 한 줄에 한 필드씩 표시합니다.

EXIT
프로그램이 종료되고 연락처를 영원히 잃어버립니다!

다른 모든 입력은 삭제됩니다.

명령이 올바르게 실행되면 프로그램은 다른 명령을 기다립니다. 사용자가 EXIT를 입력하면 중지됩니다.

실행 파일에 관련 이름을 지정합니다.


Exercise 02: The Job Of Your Dreams
Account.hpp, tests.cpp 및 로그 파일은 모듈의 인트라넷 페이지에서 다운로드할 수 있습니다.

오늘은 GlobalBanksters United에서의 첫날입니다. 채용 테스트를 성공적으로 통과한 후(친구가 보여준 몇 가지 Microsoft Office 기술 덕분에) 개발 팀에 합류했습니다.
또한 채용 담당자는 귀하가 Adobe Reader를 얼마나 빨리 설치했는지에 놀랐습니다. 그 작은 엑스트라는 모든 것을 변화시켰고 당신이 모든 상대(다른 지원자들)를 물리치는데 도움을 주었다: 당신은 성공했다!

어쨌든, 너의 매니저가 방금 너에게 할 일을 좀 줬어. 첫 번째 작업은 손실된 파일을 다시 만드는 것입니다. 오류가 발생하여 실수로 소스 파일이 삭제되었습니다.
안타깝게도 동료들은 Git가 무엇인지 모르고 USB 키를 사용하여 코드를 공유합니다. 이쯤 되면 지금 당장 이곳을 떠나는 것이 타당할 것이다.
하지만, 당신은 머물기로 결정합니다. 도전이 받아들여졌다!

당신의 동료 개발자들은 당신에게 많은 파일을 준다. tests.cpp를 컴파일하면 누락된 파일이 Account.cpp인 것으로 나타납니다.
다행이네요, Account.hpp 헤더 파일이 저장되었습니다. 로그 파일도 있습니다. 계정 클래스가 어떻게 구현되었는지 이해하기 위해 사용할 수 있습니다.

Account.cpp 파일 재생성을 시작합니다. 단 몇 분 만에, 당신은 순수한 멋진 C++의 몇 줄을 코딩한다.
컴파일에 몇 번 실패하면 프로그램이 테스트를 통과합니다. 출력은 로그 파일에 저장된 것과 완벽하게 일치합니다
(로그 파일에 저장된 테스트가 고용되기 전에 실행되었기 때문에 분명히 다를 타임스탬프는 제외).

소멸자가 호출되는 순서는 컴파일러/운영 체제에 따라 다를 수 있습니다. 그래서 파괴자들은 역순으로 호출될 수도 있다.

연습 02를 하지 않고 이 모듈을 통과할 수 있습니다.
